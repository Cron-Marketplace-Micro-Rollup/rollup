import { ActionSchema, FIFOStrategy, MicroRollup } from "@stackr/stackr-js";
import bodyParser from "body-parser";
import express, { Request, Response } from "express";
import { stackrConfig } from "../stackr.config";
import { CronRollup, StateVariable, cronSTF } from "./state";
import { StateMachine } from "@stackr/stackr-js/execution";

// this file is generated by the deployment script
import * as genesisState from "../genesis-state.json";
import actionSchemaType from "./action-schema-type";

const rollup = async () => {
  const counterFsm = new StateMachine({
    state: new CronRollup(genesisState.state as StateVariable),
    stf: cronSTF,
  });

  const actionInput = new ActionSchema("cron-actions", actionSchemaType);

  const buildStrategy = new FIFOStrategy();

  const { state, actions, events } = await MicroRollup({
    config: stackrConfig,
    useState: counterFsm,
    useAction: actionInput,
    useBuilder: { strategy: buildStrategy, autorun: true },
    useSyncer: { autorun: true },
  });

  // events.action.onEvent(ActionEvents.SUBMIT_ACTION, (action) => {
  //   console.log("action submitted", action);
  // });

  // events.batcher.onEvent(BatcherEvents.BATCH_ACTION, (batch) => {
  //   console.log("action batched", batch);
  // });

  // events.builder.onEvent(BuilderEvents.ORDER_BATCH, (batch) => {
  //   console.log("action batch ordered", batch);
  // });

  return { state, actions };
};

const app = express();
app.use(bodyParser.json());
const { actions, state } = await rollup();

app.get("/", (req: Request, res: Response) => {
  res.send({ rollupState: state.get().state.getState() });
});

app.post("/", async (req: Request, res: Response) => {
  const schema = actions.getSchema("cron-actions");

  if (!schema) {
    res.status(400).send({ message: "error" });
    return;
  }

  let acks = [];
  for (let request of req.body) {
    // console.log("--- Processing ----");
    // console.log(request);
    // console.log("---------------------");
    // if (request.payload.type === "finishJob") {
    //   let jobs = state.get().state.getState().jobs;
    //   console.log("Mark the following as finished");
    //   console.log(
    //     jobs[
    //       jobs.findIndex((j) => j.id === request.payload.jobActionsParams.jobId)
    //     ]
    //   );
    //   // console.log(jobs);
    //   console.log("-------------------------");
    // }
    try {
      request.payload = {
        ...request.payload,
        currentTimestamp: new Date().getTime().toString(),
      };

      const newAction = schema.newAction(request);
      const ack = await actions.submit(newAction);
      acks.push(ack);
    } catch (e: any) {
      // res.status(400).send({ error: e.message });
      console.log(e);
      break;
    }
  }

  res.status(201).send({ acks });
});

app.listen(3000, () => {
  console.log("listening on port 3000");
});

// actionEventsEmitter.on(ActionEvents.SUBMIT_ACTION, (data) => {
//   console.log("submit_action - Event triggered : ", data.payload);
// });

// executorEventsEmitter.on(ExecutorEvents.EXECUTE_SINGLE, (data) => {
//   console.log("execute_single - Event triggered : ", data);
// });
